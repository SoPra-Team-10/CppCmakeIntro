\documentclass[aspectratio=169]{beamer}

\usepackage[utf8]{inputenc}
\usepackage{soul}
\usepackage{pdfpcnotes}
\usepackage{listings}

\usetheme{Hannover}
\usecolortheme{dove}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\lstset{language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}


\title{C++, CMake und GTest}
\author{Paul Nykiel}
\date{\today}

\begin{document}
\maketitle
\frame{
    \tableofcontents
}

\section{Einleitung}
\begin{frame}
    \frametitle{Was ist C++}
    \begin{itemize}
        \item \st{C with classes} \pnote{Ursprünglicher Name}
        \item C++11! \pnote{Neuer Standard inzwischen 17 bald 20}
        \item Standardisiert und offen \pnote{Viele Compiler}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{C++ im Vergleich zu Java, C\#}
    \begin{itemize}
        \item Undefiniertes Verhalten 
            \pnote{Null-Pointer, fehlendes Return, division durch Null. Kann nicht vom Compiler kontrolliert werden und zur Runtime gibt es keine passnden Mechanismen  z.B. Microcontroller}
            \pause
        \item Keine automatische Speicherverwaltung 
            \pnote{Performanter Code! Systemnah! Wenn benötigt liefert die STL passende Container, nicht der Compiler}
            \pause
        \item Kleiner Sprachkern 
            \pnote{60 Schlüsselwörter, C\# z.B. 86. Keine UI, kein Networking...}
            \pause
        \item Templates 
            \pnote{Nicht generics, viel mächtiger, z.B. Boost MSM, sichere Pointer (Guideline support library)}
            \pause
        \item Operatorenüberladung
            \pnote{Bsp. Vektor}
            \pause
        \item Tendentiell weniger tiefe Vererbung
            \pnote{Z.b. Container und Iteratoren, keine Überklasse aber Eigenschaften (forward-Iterator), dadurch weniger Boilerplate}
            \pause
        \item Mehrfachvererbung
            \pnote{Dadurch keine Interfaces notwendig}
            \pause
        \item Definierte Objektlebenszeit
            \pnote{Konstruktor, Destruktor, Scope}
    \end{itemize}
\end{frame}

\section{Ein erstes C++ Programm}

\begin{frame}
    \frametitle{Beispiel: Hello World}
    \pnote{Hello World. Erklärung: include, keine main-Klasse, namespaces, Operatorenüberladung}
\end{frame}

\begin{frame}
    \frametitle{Vom Sourcecode zur ausführbaren Datei}
    \begin{itemize}
        \item Präprozessor 
            \pnote{Erklärung include und define an Hello World Bsp (gcc -E), einfache Textersetzung}
            \pause
        \item C++-Compiler 
            \pnote{Übersetzten von der Übersetzungseinheit in Maschinencode}
            \pause
        \item Linker 
            \pnote{Baut Programm zusammen und sucht Funktionen in anderen Übersetzungseinheiten}
            \pause
        \item includes sichern Typkonsitenz
            \pnote{Unterschied Definition und Deklaration, Doku im Header gut für Übersicht}
            \pause
        \item Templates müssen im Header definiert werden
            \pnote{Compiler muss alle instanziierungen kennen, langsamer Buildprozess}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Beispiel: Eine zweite Übersetzungseinheit}
    \pnote{Zweites Cpp File, alles einfach in g++ schmeißen,
    Message als std::string (nicht ref)}
\end{frame}

\section{CMake}

\begin{frame}
    \frametitle{Warum CMake}
    \begin{itemize}
        \item Nur geänderte Übersetzungseinheiten neu kompilieren 
            \pnote{erkennt welche Files geändert wurde}
            \pause
        \item Einzelner Befehl an Compiler wird zu kompliziert
            \pnote{Vor allem bei vielen Flags}
            \pause
        \item Portabilität
            \pnote{GCC wird nie explizit genannt, es wird nur ein Compiler auf Basis von Env-Variablen gesucht Flags Portabel z.B. Version}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Beispiel CMake}
    \pnote{Einfaches CMake File dazu bauen}
    %TODO wie muss das aussehen?
\end{frame}

%TODO Hier eventuell SFML

\section{Mehr C++}

\begin{frame}
    \frametitle{Copy}
    \begin{itemize}
        \item \lstinline{std::vector<int> a = b;}
            \pause
        \item Alles wird immer kopiert 
            \pnote{Funktionsargumente, Zuweisung.... Explizit große Container erwähnen}
            \pause
        \item Simpel 
            \pnote{Vgl. komisches Java Verhalten}
            \pause
        \item Performance nicht gut
            \pnote{Aber Performance sehr wichtig in C++}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Pointer}
    \begin{itemize}
        \item Pointer 
            \pnote{Vererbt von C}
            \pause
        \item Angst!
            \pause
        \item Gefährlich!
            \pause
        \item Böse!
            \pause
        \item Nicht schlimm aber viel Potential sachen kaputt zu machen
            \pnote{Leaks, Owner, selbst Borchert macht Fehler bei malloc in Klausur}
            \pause
        \item Gehört nicht in die Anwendungslogik
            \pnote{Permanente Fehlerquelle, Zeitverschwendung}
            \pause
        \item
            \lstinline{int b = 17; int *a = &b;}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Smart-Pointer}
    \begin{itemize}
        \item Funktionen aus der Standardlibrary
            \pnote{Erwähnung Operatorenüberladung und Lifetime}
            \pause
        \item unique\_ptr 
            \pnote{Quasi Drop-In-Replacement für Raw-Ptr, machen selber den Speicher am Ende der Lebenszeit Frei}
            \pause
        \item Genau ein Owner
            \pnote{Explizit verboten zu kopieren (=delete), Bsp. kopieren in Klasse, jetzt uneindeutiger Owner}
            \pause
        \item
            \lstinline{std::unique\_ptr<int> a = std::make\_unique(17);}
            \pause
        \item shared\_ptr 
            \pnote{Zusätzlich Zählen von Instanzen (siehe Copy-Constructor)}
            \pause
        \item Quasi immer nutzbar
            \pnote{Etwas weniger performant}
        \item
            \lstinline{std::shared\_ptr<int> a = std::make\_shared(17);}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Referenzen}
    \begin{itemize}
        \item Sprachfeature kein Library-Feature
            \pnote{Werden vom Compiler zu Pointern gemacht}
            \pause
        \item Können nicht null sein
            \pnote{Zeigen immer auf anderes Objekt, eine Art Alias}
            \pause
        \item Können aber ungültig werden
            \pnote{z.B. lokale Variablen}
        \item
            \lstinline{int b = 17; int &a = b;}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Zusammenfassung Pointer}
    \begin{itemize}
        \item Raw-Pointer: Wird quasi nie verwendet
            \pnote{Ausser pre C++11 und mit C APIs}
            \pause
        \item Unique-Pointer: Ersatz für Raw-Pointer
            \pnote{Limitierung: Ein Owner}
            \pause
        \item Shared-Pointer: Sichere Pointer für beliebig viele Ownerr
            \pnote{Am Ähnlichsten zu Java}
            \pause
        \item Referenzen: Oftmals um Kopien zu vermeiden
            \pnote{Sprachfeature}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Beispiel: Referenzen}
    \pnote{Frage welche Sorte Pointer. HelloWorld Lib Ergänzen mit Referenzen, jetzt in CLIon}
\end{frame}

\section{Ein bisschen Theorie}

\begin{frame}
    \frametitle{Const-Correctness}
    \begin{itemize}
        \item Alles per Referenz: Super Effizient aber Fehlerquelle
            \pnote{Beispiel: ausversehen einfügen in Map}
            \pause
        \item Const-Referenzen
            \pnote{Ergänze Beispiel}
            \pause
        \item Const-Memberfunktionen
            \pnote{Beispiel getter}
            \pause
        \item Mutable
            \pnote{Beispiel Mutex, nicht immer!}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Beispiel: Const-Correctness}
    \pnote{const einfügen}
\end{frame}

\begin{frame}
    \frametitle{RAII}
    \begin{itemize}
        \item Resource acquisition is initialization
            \pnote{Fehlerreduktion, Einfachheit}
            \pause
        \item Objekt akquiriert Resourcen im Konstruktor und gibt sie im
            Destruktor frei
            \pnote{Bsp. Datei, Mutex, Vector. Vgl try catch finally java}
            \pause
        \item
            \lstinputlisting{examples/raii.cpp}
            \pnote{Trailing return type, Const-Correctness, Objekte werden im Konstruktor initialisiert, alle Objekte werden im Konstruktor geschlossen} 
    \end{itemize}
\end{frame}

\section{OOP in C++}

\begin{frame}
    \frametitle{Klassendeklaration}
    \lstinputlisting{examples/class.h}
    \pnote{Vererbung, Sichtbarkeit von Vererbung, public, private, Konstruktor, Trailing return type, const Const-Correctness}
\end{frame}

\begin{frame}
    \frametitle{Klassendefinition}
    \lstinputlisting{examples/class.cpp}
    \pnote{Initializierung in Braced-Initializer, Super-Konstruktor, this als Pointer}
\end{frame}

\section{STL}

\begin{frame}
    \frametitle{STL}
    \begin{itemize}
        \item Standard Template Library
        \item String, Math, Date \& Time
        \item Container
        \item IO
        \item Concurrency
    \end{itemize}
\end{frame}

\end{document}
