\documentclass[aspectratio=169]{beamer}

\usepackage[utf8]{inputenc}
\usepackage{soul}
\usepackage{pdfpcnotes}
\usepackage{listings}

\usetheme{Hannover}
\usecolortheme{dove}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\lstset{language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{purple}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}


\title{C++, CMake und GTest}
\author{Paul Nykiel}
\date{\today}

\begin{document}
\maketitle
\frame{
    \tableofcontents
}

\section{Einleitung}
\begin{frame}
    \frametitle{Was ist C++}
    \begin{itemize}
        \item \st{C with classes} \pnote{Ursprünglicher Name}
        \item C++11! \pnote{Neuer Standard inzwischen 17 bald 20}
        \item Standardisiert und offen \pnote{Viele Compiler}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{C++ im Vergleich zu Java, C\#}
    \begin{itemize}
        \item Undefiniertes Verhalten 
            \pnote{Null-Pointer, fehlendes Return, division durch Null. Kann nicht vom Compiler kontrolliert werden und zur Runtime gibt es keine passnden Mechanismen  z.B. Microcontroller}
            \pause
        \item Keine automatische Speicherverwaltung 
            \pnote{Performanter Code! Systemnah! Wenn benötigt liefert die STL passende Container, nicht der Compiler}
            \pause
        \item Kleiner Sprachkern 
            \pnote{60 Schlüsselwörter, C\# z.B. 86. Keine UI, kein Networking...}
            \pause
        \item Templates 
            \pnote{Nicht generics, viel mächtiger, z.B. Boost MSM, sichere Pointer (Guideline support library)}
            \pause
        \item Operatorenüberladung
            \pnote{Bsp. Vektor}
            \pause
        \item Tendentiell weniger tiefe Vererbung
            \pnote{Z.b. Container und Iteratoren, keine Überklasse aber Eigenschaften (forward-Iterator), dadurch weniger Boilerplate}
            \pause
        \item Mehrfachvererbung
            \pnote{Dadurch keine Interfaces notwendig}
            \pause
        \item Definierte Objektlebenszeit
            \pnote{Konstruktor, Destruktor, Scope}
    \end{itemize}
\end{frame}

\section{Ein erstes C++ Programm}

\begin{frame}
    \Huge{Beispiel: Hello World}
    \pnote{Hello World. Erklärung: include, keine main-Klasse, namespaces, Operatorenüberladung}
\end{frame}

\begin{frame}
    \frametitle{Vom Sourcecode zur ausführbaren Datei}
    \begin{itemize}
        \item Präprozessor 
            \pnote{Erklärung include und define an Hello World Bsp (gcc -E), einfache Textersetzung}
            \pause
        \item C++-Compiler 
            \pnote{Übersetzten von der Übersetzungseinheit in Maschinencode}
            \pause
        \item Linker 
            \pnote{Baut Programm zusammen und sucht Funktionen in anderen Übersetzungseinheiten}
            \pause
        \item includes sichern Typkonsitenz
            \pnote{Unterschied Definition und Deklaration, Doku im Header gut für Übersicht}
            \pause
        \item Templates müssen im Header definiert werden
            \pnote{Compiler muss alle instanziierungen kennen, langsamer Buildprozess}
    \end{itemize}
\end{frame}

\begin{frame}
    \Huge{Beispiel: Eine zweite Übersetzungseinheit}
    \pnote{Zweites Cpp File, alles einfach in g++ schmeißen,
    Message als std::string (nicht ref)}
\end{frame}

\section{CMake}

\begin{frame}
    \frametitle{Warum CMake}
    \begin{itemize}
        \item Nur geänderte Übersetzungseinheiten neu kompilieren 
            \pnote{erkennt welche Files geändert wurde}
            \pause
        \item Einzelner Befehl an Compiler wird zu kompliziert
            \pnote{Vor allem bei vielen Flags}
            \pause
        \item Portabilität
            \pnote{GCC wird nie explizit genannt, es wird nur ein Compiler auf Basis von Env-Variablen gesucht Flags Portabel z.B. Version}
    \end{itemize}
\end{frame}

\begin{frame}
    \Huge{Beispiel: CMake}
    \pnote{Einfaches CMake File dazu bauen}
    %TODO wie muss das aussehen?
\end{frame}

%TODO Hier eventuell SFML

\section{Mehr C++}

\begin{frame}
    \frametitle{Copy}
    \begin{itemize}
        \item \lstinline{std::vector<int> a = b;}
            \pause
        \item Alles wird immer kopiert 
            \pnote{Funktionsargumente, Zuweisung.... Explizit große Container erwähnen}
            \pause
        \item Simpel 
            \pnote{Vgl. komisches Java Verhalten}
            \pause
        \item Performance nicht gut
            \pnote{Aber Performance sehr wichtig in C++}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Pointer}
    \begin{itemize}
        \item Pointer 
            \pnote{Vererbt von C}
            \pause
        \item Angst!
            \pause
        \item Gefährlich!
            \pause
        \item Böse!
            \pause
        \item Nicht schlimm aber viel Potential sachen kaputt zu machen
            \pnote{Leaks, Owner, selbst Borchert macht Fehler bei malloc in Klausur}
            \pause
        \item Gehört nicht in die Anwendungslogik
            \pnote{Permanente Fehlerquelle, Zeitverschwendung}
            \pause
        \item
            \lstinline{int b = 17; int *a = &b;}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Smart-Pointer}
    \begin{itemize}
        \item Funktionen aus der Standardlibrary
            \pnote{Erwähnung Operatorenüberladung und Lifetime}
            \pause
        \item unique\_ptr 
            \pnote{Quasi Drop-In-Replacement für Raw-Ptr, machen selber den Speicher am Ende der Lebenszeit Frei}
            \pause
        \item Genau ein Owner
            \pnote{Explizit verboten zu kopieren (=delete), Bsp. kopieren in Klasse, jetzt uneindeutiger Owner}
            \pause
        \item
            \lstinline{std::unique\_ptr<int> a = std::make\_unique(17);}
            \pause
        \item shared\_ptr 
            \pnote{Zusätzlich Zählen von Instanzen (siehe Copy-Constructor)}
            \pause
        \item Quasi immer nutzbar
            \pnote{Etwas weniger performant}
        \item
            \lstinline{std::shared\_ptr<int> a = std::make\_shared(17);}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Referenzen}
    \begin{itemize}
        \item Sprachfeature kein Library-Feature
            \pnote{Werden vom Compiler zu Pointern gemacht}
            \pause
        \item Können nicht null sein
            \pnote{Zeigen immer auf anderes Objekt, eine Art Alias}
            \pause
        \item Können aber ungültig werden
            \pnote{z.B. lokale Variablen}
        \item
            \lstinline{int b = 17; int &a = b;}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Zusammenfassung Pointer}
    \begin{itemize}
        \item Raw-Pointer: Wird quasi nie verwendet
            \pnote{Ausser pre C++11 und mit C APIs}
            \pause
        \item Unique-Pointer: Ersatz für Raw-Pointer
            \pnote{Limitierung: Ein Owner}
            \pause
        \item Shared-Pointer: Sichere Pointer für beliebig viele Ownerr
            \pnote{Am Ähnlichsten zu Java}
            \pause
        \item Referenzen: Oftmals um Kopien zu vermeiden
            \pnote{Sprachfeature}
    \end{itemize}
\end{frame}

\begin{frame}
    \Huge{Beispiel: Referenzen}
    \pnote{Frage welche Sorte Pointer. HelloWorld Lib Ergänzen mit Referenzen, jetzt in CLIon}
\end{frame}

\section{Design Pattern}

\begin{frame}
    \frametitle{Const-Correctness}
    \begin{itemize}
        \item Alles per Referenz: Super Effizient aber Fehlerquelle
            \pnote{Beispiel: ausversehen einfügen in Map}
            \pause
        \item Const-Referenzen
            \pnote{Ergänze Beispiel}
            \pause
        \item Const-Memberfunktionen
            \pnote{Beispiel getter}
            \pause
        \item Mutable
            \pnote{Beispiel Mutex, nicht immer!}
    \end{itemize}
\end{frame}

\begin{frame}
    \Huge{Beispiel: Const-Correctness}
    \pnote{const einfügen}
\end{frame}

\begin{frame}
    \frametitle{RAII}
    \begin{itemize}
        \item Resource acquisition is initialization
            \pnote{Fehlerreduktion, Einfachheit}
            \pause
        \item Objekt akquiriert Resourcen im Konstruktor und gibt sie im
            Destruktor frei
            \pnote{Bsp. Datei, Mutex, Vector. Vgl try catch finally java}
            \pause
        \item
            \lstinputlisting{examples/raii.cpp}
            \pnote{Trailing return type, Const-Correctness, Objekte werden im Konstruktor initialisiert, alle Objekte werden im Konstruktor geschlossen} 
    \end{itemize}
\end{frame}

\section{OOP in C++}

\begin{frame}
    \frametitle{Klassendeklaration}
    \lstinputlisting{examples/class.h}
    \pnote{Vererbung, Sichtbarkeit von Vererbung, public, private, Konstruktor, Trailing return type, const Const-Correctness}
\end{frame}

\begin{frame}
    \frametitle{Klassendefinition}
    \lstinputlisting{examples/class.cpp}
    \pnote{Initializierung in Braced-Initializer, Super-Konstruktor, this als Pointer}
\end{frame}

\begin{frame}
    \Huge{Beispiel: HelloWorld OOP}
\end{frame}

\section{Noch mehr C++}
\begin{frame}
    \frametitle{Type-Deduction}
    \lstinputlisting{examples/typededuction.cpp}
    \pnote{Typ wird hergeleitet, oftmals Praktisch (vgl. Iterator), spart redundanz. Potentielle Fehlerquelle, z.B. Proxy klasse (vgl. std::vector<bool>)}
\end{frame}

\begin{frame}
    \frametitle{Lambda-Ausdrücke und Funktionen}
    \lstinputlisting{examples/lambda.cpp}
    \pnote{Lambda, capute group, argumente. Bind um Argumente fest zu binden (oder Reihenfolge ändern)}
\end{frame}

\begin{frame}
    \frametitle{Kurzeinführung Templates}
    \lstinputlisting{examples/template.cpp}
    \pnote{Definition von template mit Typen, Type Deduktion}
\end{frame}

\section{STL}

\begin{frame}
    \frametitle{STL}
    \begin{itemize}
        \item Standard Template Library
            \pnote{Standardlibrary, wird von der libc zur Verfügung gestellt, nicht immer existent z.B. MC, aber mit OS schon. Grob Aufteilung:}
            \pause
        \item Utility
            \pnote{String, Math, Date \& Time, Smart Pointer}
            \pause
        \item Container
            \pnote{Strukturierte Sammlung von Objekten}
            \pause
        \item Algorithmen
            \pnote{Standardalgorithmen oftmals mit Containern}
        \item IO
            \pnote{Standard-IO, Dateizugriff}
            \pause
        \item Concurrency
            \pnote{Threads und Locking Mechanismen}
    \end{itemize}
    \pnote{Jeweils kleine Auswahl zeigen}
\end{frame}

\begin{frame}
    \frametitle{Utility}
    \begin{itemize}
        \item \lstinline{std::string}
            \pnote{Wie in Java}
            \pause
        \item \lstinline{std::unique\_ptr<T>}
            \pnote{Siehe oben}
            \pause
        \item \lstinline{std::shared\_ptr<T>}
            \pnote{Siehe oben}
            \pause
        \item \lstinline{std::chrono}
            \pnote{Nur der Namespace, diverseste Funktionen}
            \pause
        \item \lstinline{std::sin()} \ldots
            \pnote{Auch exotisches wie Riemann-Zeta Funktion}
            \pause
        \item \lstinline{std::complex} \ldots
            \pnote{Komplexe Zahlen und Hilfsfunktionen}
            \pause
        \item \lstinline{std::normal\_distribution} \ldots
            \pnote{Diverse Verteilungen und RNGs}
            \pause
        \item \lstinline{std::function<T(A...)>}
            \pnote{Behandlung von Callable (Funktionen) wie Variablen (vgl. Funktionspointer)}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Container}
    \begin{itemize}
        \item \lstinline{std::array<T, N>}
            \pnote{Größe muss zu Compile-Time feststehen, wie Array in C nur Sicher, Zugriff O(1), Einfügen unmöglich}
            \pause
        \item \lstinline{std::vector<T>}
            \pnote{Dynamisch angelegtes Array, Elemente können hinzugefügt werden aber nicht effizient, Zugriff O(1), Einfügen worst case O(n)}
            \pause
        \item \lstinline{std::deque<T>}
            \pnote{Verlinkte Array-Liste, Ausprache!, Zugriff O(1) (aber langsamer als vector), Einfügen an einem Ende O(1), Einfügen in der Mitte O(n)}
            \pause
        \item \lstinline{std::list<T>} und \lstinline{std::forward\_list<T>}
            \pnote{Einfach bzw. doppelt verkettete Liste, Zugriff O(1), Einfügen O(1)}
            \pause
        \item \lstinline{std::set<T>} und \lstinline{std::map<K, V>}
            \pnote{Menge und Abbildung von Key auf Value, finden von Elementen in O(log(n(), einfügen in O(log(n))}
            \pause
        \item \lstinline{std::tuple<T...>} und \lstinline{std::pair<T1, T2>}
            \pnote{Genau genommen kein Container, Sammlung von mehreren bzw. 2 Objekten von unterschiedlichem Typ. Typen und Anzahl müssen zu Compile-Time bekannt sein}
            \pause
        \item \lstinline{std::optional<T>}
            \pnote{Variable vom Typ T die nicht existieren muss, zum Beispiel als Return-Wert mit Fehler}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Iteratoren}
    \lstinputlisting{examples/iterator.cpp}
    \pnote{Type deduction wäre möglich. Wie Pointer nur abstrakt, z.B. auch bei Liste, zentrales Element für Container und Algorithmen}
\end{frame}

\begin{frame}
    \frametitle{Algorithmen}
    \begin{itemize}
        \item \lstinline{std::transform}
            \pnote{Wendet eine Funktion auf jedes Element eines Containers an}
            \pause
        \item \lstinline{std::sort}
            \pnote{Sortiert ein Container, es kann ein eigener Komperator angegeben werden}
            \pause
        \item \lstinline{std::max}, \lstinline{std::max\_element} \ldots
            \pnote{Findet größtes/kleinstes Element/Index}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{IO}
    \pnote{Alles auf Basis von "Streams"}
    \begin{itemize}
        \item \lstinline{std::istream} und \lstinline{std::ostream}
            \pnote{Abstrakte input und output Streams}
            \pause
        \item \lstinline{std::cout}, \lstinline{std::cerr} und \lstinline{std::cin}
            \pnote{Stellen Streams zur Verfügung für Standardein-/Ausgabe}
            \pause
        \item \lstinline{std::fstream}
            \pnote{Dateistream (RAII!)}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Concurrency}
    \begin{itemize}
        \item \lstinline{std::thread}
            \pnote{Startet neuen Thread aus callable}
            \pause
        \item \lstinline{std::launch} und \lstinline{std::future<T>}
            \pnote{Abstraktion, asynchroner Funktionsaufruf, ergebniss in Future}
            \pause
        \item \lstinline{std::mutex} und \lstinline{std::lock<T>}
            \pnote{Gegenseitiger Ausschluss, Lock sperrt und entsperrt automatisch (RAII!)}
    \end{itemize}
\end{frame}

\section{Praxis}

\section{Tools}
\begin{frame}
    \frametitle{GTest}
    \lstinputlisting{examples/gtest.cpp}
    \pnote{Diverseste Bedinungen, z.B. auch Float, integration in CLion}
\end{frame}

\begin{frame}
    \frametitle{Doxygen}
    \lstinputlisting{examples/doxygen.cpp}
    \pnote{Vergleiche JavaDoc, besonderheit: tparam}
\end{frame}

\begin{frame}
    \frametitle{Debugging und Fehlersuche}
    \begin{itemize}
        \item GDB o.ä.
            \pnote{Debugger, quasi beliebig, wichtigestes Tool}
            \pause
        \item Valgrind
            \pnote{Erkennt Speicherlecks, undefiniertes Verhalten, Langsam}
            \pause
        \item LibAdressSanitizer (Asan)
            \pnote{Wie Valgrind nur schnell und neuer}
            \pause
        \item clang-tidy
            \pnote{Statische Analyse, Fehler vor der Compilieren entdecken, Demo in CLion}
    \end{itemize}
\end{frame}

\begin{frame}
    \Huge{Beispiel: Tools}
    \pnote{Segfault bauen, GDB nutzen Valgrind und Asan nutzen in CLion}
\end{frame}

\section{Abschluss}

\begin{frame}
    \frametitle{Mehr Informationen}
    \begin{itemize}
        \item en.cppreference.com
            \pnote{Dokumentation der Sprache und STL, deutsche Version ist Shit}
            \pause
        \item github.com/isocpp/CppCoreGuidelines
            \pnote{Gut für Designentscheidungen}
            \pause
        \item godbolt.org
            \pnote{Was erzeugt der Compiler für Code auf unterschiedlichen Plattformen, eher als Spielzeug}
            \pause
        \item github.com/SoPra-Team-10/CppCMakeIntro
            \pnote{Dieser Vortrag}
    \end{itemize}
\end{frame}

\end{document}
