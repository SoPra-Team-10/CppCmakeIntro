[notes]
### 4
Kurz Hintergrund für Einordnung
Ursprünglicher Name, da initial nur Erweiterung von C um Objektorientung
Inzwischen weiter von C entfernt, mehr Konstrukte um sicheren und effizienten Code zu schreiben (Verweis Titel). Neuer Standard inzwischen 17 bald 20. Benennung: 98: 98 und 03. 11: 11 - 17
Viele Compiler, Gute Dokumentation, Entscheidungen werden im Komitee getroffen, nicht von einzelnen Firmen
Embedded, Betriebssysteme, Systemnahe Entwicklung, Signalverarbeitung (Codierung), Desktop-Anwendungen, Spiele, Server-Anwendungen, HPC...
Sicheres Typensystem, checks zur Compile Time (unterschied zur Run Timer hervorheben), maschinennah
### 4
Kurz Hintergrund für Einordnung
Ursprünglicher Name, da initial nur Erweiterung von C um Objektorientung
Inzwischen weiter von C entfernt, mehr Konstrukte um sicheren und effizienten Code zu schreiben (Verweis Titel). Neuer Standard inzwischen 17 bald 20. Benennung: 98: 98 und 03. 11: 11 - 17
Viele Compiler, Gute Dokumentation, Entscheidungen werden im Komitee getroffen, nicht von einzelnen Firmen
Embedded, Betriebssysteme, Systemnahe Entwicklung, Signalverarbeitung (Codierung), Desktop-Anwendungen, Spiele, Server-Anwendungen, HPC...
Sicheres Typensystem, checks zur Compile Time (unterschied zur Run Timer hervorheben), maschinennah
### 4
Kurz Hintergrund für Einordnung
Ursprünglicher Name, da initial nur Erweiterung von C um Objektorientung
Inzwischen weiter von C entfernt, mehr Konstrukte um sicheren und effizienten Code zu schreiben (Verweis Titel). Neuer Standard inzwischen 17 bald 20. Benennung: 98: 98 und 03. 11: 11 - 17
Viele Compiler, Gute Dokumentation, Entscheidungen werden im Komitee getroffen, nicht von einzelnen Firmen
Embedded, Betriebssysteme, Systemnahe Entwicklung, Signalverarbeitung (Codierung), Desktop-Anwendungen, Spiele, Server-Anwendungen, HPC...
Sicheres Typensystem, checks zur Compile Time (unterschied zur Run Timer hervorheben), maschinennah
### 4
Kurz Hintergrund für Einordnung
Ursprünglicher Name, da initial nur Erweiterung von C um Objektorientung
Inzwischen weiter von C entfernt, mehr Konstrukte um sicheren und effizienten Code zu schreiben (Verweis Titel). Neuer Standard inzwischen 17 bald 20. Benennung: 98: 98 und 03. 11: 11 - 17
Viele Compiler, Gute Dokumentation, Entscheidungen werden im Komitee getroffen, nicht von einzelnen Firmen
Embedded, Betriebssysteme, Systemnahe Entwicklung, Signalverarbeitung (Codierung), Desktop-Anwendungen, Spiele, Server-Anwendungen, HPC...
Sicheres Typensystem, checks zur Compile Time (unterschied zur Run Timer hervorheben), maschinennah
### 4
Kurz Hintergrund für Einordnung
Ursprünglicher Name, da initial nur Erweiterung von C um Objektorientung
Inzwischen weiter von C entfernt, mehr Konstrukte um sicheren und effizienten Code zu schreiben (Verweis Titel). Neuer Standard inzwischen 17 bald 20. Benennung: 98: 98 und 03. 11: 11 - 17
Viele Compiler, Gute Dokumentation, Entscheidungen werden im Komitee getroffen, nicht von einzelnen Firmen
Embedded, Betriebssysteme, Systemnahe Entwicklung, Signalverarbeitung (Codierung), Desktop-Anwendungen, Spiele, Server-Anwendungen, HPC...
Sicheres Typensystem, checks zur Compile Time (unterschied zur Run Timer hervorheben), maschinennah
### 5
Null-Pointer, fehlendes Return, division durch Null. Kann nicht vom Compiler kontrolliert werden und zur Runtime gibt es keine passnden Mechanismen z.B. Microcontroller. Aber quasi jede Sprache hat undefiniertes Verhalten bezeichnet es aber nicht so (z.B. Race-Conditions)
Keine Aufgabe der Sprache, wenn benötigt liefert die STL passende Container. Bei Microcontroller oder Echtzeitanwendungen nicht gewünscht. Unterscheidung Heap und Stack hervorheben.
60 Schlüsselwörter, C\# z.B. 86. Keine UI, kein Networking...
Nicht generics, viel mächtiger, z.B. Boost MSM, sichere Pointer (Guideline support library), Turing-vollständig
Bsp. Vektor, Iteratoren...
Z.b. Container und Iteratoren, keine Überklasse aber Eigenschaften (forward-Iterator), dadurch weniger Boilerplate
Dadurch keine Interfaces notwendig, aber selten genutzt
Konstruktor, Destruktor, Scope
### 5
Null-Pointer, fehlendes Return, division durch Null. Kann nicht vom Compiler kontrolliert werden und zur Runtime gibt es keine passnden Mechanismen z.B. Microcontroller. Aber quasi jede Sprache hat undefiniertes Verhalten bezeichnet es aber nicht so (z.B. Race-Conditions)
Keine Aufgabe der Sprache, wenn benötigt liefert die STL passende Container. Bei Microcontroller oder Echtzeitanwendungen nicht gewünscht. Unterscheidung Heap und Stack hervorheben.
60 Schlüsselwörter, C\# z.B. 86. Keine UI, kein Networking...
Nicht generics, viel mächtiger, z.B. Boost MSM, sichere Pointer (Guideline support library), Turing-vollständig
Bsp. Vektor, Iteratoren...
Z.b. Container und Iteratoren, keine Überklasse aber Eigenschaften (forward-Iterator), dadurch weniger Boilerplate
Dadurch keine Interfaces notwendig, aber selten genutzt
Konstruktor, Destruktor, Scope
### 5
Null-Pointer, fehlendes Return, division durch Null. Kann nicht vom Compiler kontrolliert werden und zur Runtime gibt es keine passnden Mechanismen z.B. Microcontroller. Aber quasi jede Sprache hat undefiniertes Verhalten bezeichnet es aber nicht so (z.B. Race-Conditions)
Keine Aufgabe der Sprache, wenn benötigt liefert die STL passende Container. Bei Microcontroller oder Echtzeitanwendungen nicht gewünscht. Unterscheidung Heap und Stack hervorheben.
60 Schlüsselwörter, C\# z.B. 86. Keine UI, kein Networking...
Nicht generics, viel mächtiger, z.B. Boost MSM, sichere Pointer (Guideline support library), Turing-vollständig
Bsp. Vektor, Iteratoren...
Z.b. Container und Iteratoren, keine Überklasse aber Eigenschaften (forward-Iterator), dadurch weniger Boilerplate
Dadurch keine Interfaces notwendig, aber selten genutzt
Konstruktor, Destruktor, Scope
### 5
Null-Pointer, fehlendes Return, division durch Null. Kann nicht vom Compiler kontrolliert werden und zur Runtime gibt es keine passnden Mechanismen z.B. Microcontroller. Aber quasi jede Sprache hat undefiniertes Verhalten bezeichnet es aber nicht so (z.B. Race-Conditions)
Keine Aufgabe der Sprache, wenn benötigt liefert die STL passende Container. Bei Microcontroller oder Echtzeitanwendungen nicht gewünscht. Unterscheidung Heap und Stack hervorheben.
60 Schlüsselwörter, C\# z.B. 86. Keine UI, kein Networking...
Nicht generics, viel mächtiger, z.B. Boost MSM, sichere Pointer (Guideline support library), Turing-vollständig
Bsp. Vektor, Iteratoren...
Z.b. Container und Iteratoren, keine Überklasse aber Eigenschaften (forward-Iterator), dadurch weniger Boilerplate
Dadurch keine Interfaces notwendig, aber selten genutzt
Konstruktor, Destruktor, Scope
### 5
Null-Pointer, fehlendes Return, division durch Null. Kann nicht vom Compiler kontrolliert werden und zur Runtime gibt es keine passnden Mechanismen z.B. Microcontroller. Aber quasi jede Sprache hat undefiniertes Verhalten bezeichnet es aber nicht so (z.B. Race-Conditions)
Keine Aufgabe der Sprache, wenn benötigt liefert die STL passende Container. Bei Microcontroller oder Echtzeitanwendungen nicht gewünscht. Unterscheidung Heap und Stack hervorheben.
60 Schlüsselwörter, C\# z.B. 86. Keine UI, kein Networking...
Nicht generics, viel mächtiger, z.B. Boost MSM, sichere Pointer (Guideline support library), Turing-vollständig
Bsp. Vektor, Iteratoren...
Z.b. Container und Iteratoren, keine Überklasse aber Eigenschaften (forward-Iterator), dadurch weniger Boilerplate
Dadurch keine Interfaces notwendig, aber selten genutzt
Konstruktor, Destruktor, Scope
### 5
Null-Pointer, fehlendes Return, division durch Null. Kann nicht vom Compiler kontrolliert werden und zur Runtime gibt es keine passnden Mechanismen z.B. Microcontroller. Aber quasi jede Sprache hat undefiniertes Verhalten bezeichnet es aber nicht so (z.B. Race-Conditions)
Keine Aufgabe der Sprache, wenn benötigt liefert die STL passende Container. Bei Microcontroller oder Echtzeitanwendungen nicht gewünscht. Unterscheidung Heap und Stack hervorheben.
60 Schlüsselwörter, C\# z.B. 86. Keine UI, kein Networking...
Nicht generics, viel mächtiger, z.B. Boost MSM, sichere Pointer (Guideline support library), Turing-vollständig
Bsp. Vektor, Iteratoren...
Z.b. Container und Iteratoren, keine Überklasse aber Eigenschaften (forward-Iterator), dadurch weniger Boilerplate
Dadurch keine Interfaces notwendig, aber selten genutzt
Konstruktor, Destruktor, Scope
### 5
Null-Pointer, fehlendes Return, division durch Null. Kann nicht vom Compiler kontrolliert werden und zur Runtime gibt es keine passnden Mechanismen z.B. Microcontroller. Aber quasi jede Sprache hat undefiniertes Verhalten bezeichnet es aber nicht so (z.B. Race-Conditions)
Keine Aufgabe der Sprache, wenn benötigt liefert die STL passende Container. Bei Microcontroller oder Echtzeitanwendungen nicht gewünscht. Unterscheidung Heap und Stack hervorheben.
60 Schlüsselwörter, C\# z.B. 86. Keine UI, kein Networking...
Nicht generics, viel mächtiger, z.B. Boost MSM, sichere Pointer (Guideline support library), Turing-vollständig
Bsp. Vektor, Iteratoren...
Z.b. Container und Iteratoren, keine Überklasse aber Eigenschaften (forward-Iterator), dadurch weniger Boilerplate
Dadurch keine Interfaces notwendig, aber selten genutzt
Konstruktor, Destruktor, Scope
### 5
Null-Pointer, fehlendes Return, division durch Null. Kann nicht vom Compiler kontrolliert werden und zur Runtime gibt es keine passnden Mechanismen z.B. Microcontroller. Aber quasi jede Sprache hat undefiniertes Verhalten bezeichnet es aber nicht so (z.B. Race-Conditions)
Keine Aufgabe der Sprache, wenn benötigt liefert die STL passende Container. Bei Microcontroller oder Echtzeitanwendungen nicht gewünscht. Unterscheidung Heap und Stack hervorheben.
60 Schlüsselwörter, C\# z.B. 86. Keine UI, kein Networking...
Nicht generics, viel mächtiger, z.B. Boost MSM, sichere Pointer (Guideline support library), Turing-vollständig
Bsp. Vektor, Iteratoren...
Z.b. Container und Iteratoren, keine Überklasse aber Eigenschaften (forward-Iterator), dadurch weniger Boilerplate
Dadurch keine Interfaces notwendig, aber selten genutzt
Konstruktor, Destruktor, Scope
### 7
Hello World. Erklärung: include, keine main-Klasse, namespaces, Operatorenüberladung, Vergleich Code-Länge mit Java
### 8
Erklärung include und define an Hello World Bsp (gcc -E), einfache Textersetzung, Erklärung an Tafel
Übersetzten von der Übersetzungseinheit in Maschinencode, Übersetzungseinheit definieren
Baut Programm zusammen und sucht Funktionen in anderen Übersetzungseinheiten
Unterschied Definition und Deklaration, Doku im Header gut für Übersicht
Compiler muss alle instanziierungen kennen, langsamer Buildprozess
### 8
Erklärung include und define an Hello World Bsp (gcc -E), einfache Textersetzung, Erklärung an Tafel
Übersetzten von der Übersetzungseinheit in Maschinencode, Übersetzungseinheit definieren
Baut Programm zusammen und sucht Funktionen in anderen Übersetzungseinheiten
Unterschied Definition und Deklaration, Doku im Header gut für Übersicht
Compiler muss alle instanziierungen kennen, langsamer Buildprozess
### 8
Erklärung include und define an Hello World Bsp (gcc -E), einfache Textersetzung, Erklärung an Tafel
Übersetzten von der Übersetzungseinheit in Maschinencode, Übersetzungseinheit definieren
Baut Programm zusammen und sucht Funktionen in anderen Übersetzungseinheiten
Unterschied Definition und Deklaration, Doku im Header gut für Übersicht
Compiler muss alle instanziierungen kennen, langsamer Buildprozess
### 8
Erklärung include und define an Hello World Bsp (gcc -E), einfache Textersetzung, Erklärung an Tafel
Übersetzten von der Übersetzungseinheit in Maschinencode, Übersetzungseinheit definieren
Baut Programm zusammen und sucht Funktionen in anderen Übersetzungseinheiten
Unterschied Definition und Deklaration, Doku im Header gut für Übersicht
Compiler muss alle instanziierungen kennen, langsamer Buildprozess
### 8
Erklärung include und define an Hello World Bsp (gcc -E), einfache Textersetzung, Erklärung an Tafel
Übersetzten von der Übersetzungseinheit in Maschinencode, Übersetzungseinheit definieren
Baut Programm zusammen und sucht Funktionen in anderen Übersetzungseinheiten
Unterschied Definition und Deklaration, Doku im Header gut für Übersicht
Compiler muss alle instanziierungen kennen, langsamer Buildprozess
### 9
Zweites Cpp File, alles einfach in g++ schmeißen, Message als std::string (nicht ref)
### 11
erkennt welche Files geändert wurde, größere Projekte kompilieren sonst jedes mal mehrere Minuten bis Stunden
Vor allem bei vielen Flags und vielen Dateien
Compiler und Flags werden unnabhängig vom Os und von installierten Compilern angegeben
### 11
erkennt welche Files geändert wurde, größere Projekte kompilieren sonst jedes mal mehrere Minuten bis Stunden
Vor allem bei vielen Flags und vielen Dateien
Compiler und Flags werden unnabhängig vom Os und von installierten Compilern angegeben
### 11
erkennt welche Files geändert wurde, größere Projekte kompilieren sonst jedes mal mehrere Minuten bis Stunden
Vor allem bei vielen Flags und vielen Dateien
Compiler und Flags werden unnabhängig vom Os und von installierten Compilern angegeben
### 12
Einfaches CMake File dazu bauen, nochmal kompilieren, Lib ändern zeigen dass main nicht neu gebaut wird
### 14
f ist Funktion list->list und b ist list. Was passiert hier, wie viele Objekte existieren, wie viel Speicher wird genutzt, wie oft wird kopiert
Funktionsargumente, Zuweisung.... Explizit große Container erwähnen
Vgl. komisches Java Verhalten. Trivial ein Objekt zu kopieren, deep copy in Java und C\# schwierig (Internet: selber implementieren oder serializieren und deserializieren)
Spricht gegen das was ich in Einleitung gesagt habe, Performance in C++ wichtig
### 14
f ist Funktion list->list und b ist list. Was passiert hier, wie viele Objekte existieren, wie viel Speicher wird genutzt, wie oft wird kopiert
Funktionsargumente, Zuweisung.... Explizit große Container erwähnen
Vgl. komisches Java Verhalten. Trivial ein Objekt zu kopieren, deep copy in Java und C\# schwierig (Internet: selber implementieren oder serializieren und deserializieren)
Spricht gegen das was ich in Einleitung gesagt habe, Performance in C++ wichtig
### 14
f ist Funktion list->list und b ist list. Was passiert hier, wie viele Objekte existieren, wie viel Speicher wird genutzt, wie oft wird kopiert
Funktionsargumente, Zuweisung.... Explizit große Container erwähnen
Vgl. komisches Java Verhalten. Trivial ein Objekt zu kopieren, deep copy in Java und C\# schwierig (Internet: selber implementieren oder serializieren und deserializieren)
Spricht gegen das was ich in Einleitung gesagt habe, Performance in C++ wichtig
### 14
f ist Funktion list->list und b ist list. Was passiert hier, wie viele Objekte existieren, wie viel Speicher wird genutzt, wie oft wird kopiert
Funktionsargumente, Zuweisung.... Explizit große Container erwähnen
Vgl. komisches Java Verhalten. Trivial ein Objekt zu kopieren, deep copy in Java und C\# schwierig (Internet: selber implementieren oder serializieren und deserializieren)
Spricht gegen das was ich in Einleitung gesagt habe, Performance in C++ wichtig
### 15
"Vererbt" von C
Pointer kurz erklären, kurz Owner (malloc/new) bzw. nur als Referenz erklären
Leaks, Owner nicht definiert, vor allem bei Librarys relevant
Pointer als Referenz
Pointer als Owner, Hier gleich ein potentieller Leak
Immer mit delete, das will doch wirklich keiner
Permanente Fehlerquelle, Zeitverschwendung, Ab jetzt als Raw-Pointer bezeichnet und nie wieder verwenden!
### 15
"Vererbt" von C
Pointer kurz erklären, kurz Owner (malloc/new) bzw. nur als Referenz erklären
Leaks, Owner nicht definiert, vor allem bei Librarys relevant
Pointer als Referenz
Pointer als Owner, Hier gleich ein potentieller Leak
Immer mit delete, das will doch wirklich keiner
Permanente Fehlerquelle, Zeitverschwendung, Ab jetzt als Raw-Pointer bezeichnet und nie wieder verwenden!
### 15
"Vererbt" von C
Pointer kurz erklären, kurz Owner (malloc/new) bzw. nur als Referenz erklären
Leaks, Owner nicht definiert, vor allem bei Librarys relevant
Pointer als Referenz
Pointer als Owner, Hier gleich ein potentieller Leak
Immer mit delete, das will doch wirklich keiner
Permanente Fehlerquelle, Zeitverschwendung, Ab jetzt als Raw-Pointer bezeichnet und nie wieder verwenden!
### 15
"Vererbt" von C
Pointer kurz erklären, kurz Owner (malloc/new) bzw. nur als Referenz erklären
Leaks, Owner nicht definiert, vor allem bei Librarys relevant
Pointer als Referenz
Pointer als Owner, Hier gleich ein potentieller Leak
Immer mit delete, das will doch wirklich keiner
Permanente Fehlerquelle, Zeitverschwendung, Ab jetzt als Raw-Pointer bezeichnet und nie wieder verwenden!
### 15
"Vererbt" von C
Pointer kurz erklären, kurz Owner (malloc/new) bzw. nur als Referenz erklären
Leaks, Owner nicht definiert, vor allem bei Librarys relevant
Pointer als Referenz
Pointer als Owner, Hier gleich ein potentieller Leak
Immer mit delete, das will doch wirklich keiner
Permanente Fehlerquelle, Zeitverschwendung, Ab jetzt als Raw-Pointer bezeichnet und nie wieder verwenden!
### 15
"Vererbt" von C
Pointer kurz erklären, kurz Owner (malloc/new) bzw. nur als Referenz erklären
Leaks, Owner nicht definiert, vor allem bei Librarys relevant
Pointer als Referenz
Pointer als Owner, Hier gleich ein potentieller Leak
Immer mit delete, das will doch wirklich keiner
Permanente Fehlerquelle, Zeitverschwendung, Ab jetzt als Raw-Pointer bezeichnet und nie wieder verwenden!
### 15
"Vererbt" von C
Pointer kurz erklären, kurz Owner (malloc/new) bzw. nur als Referenz erklären
Leaks, Owner nicht definiert, vor allem bei Librarys relevant
Pointer als Referenz
Pointer als Owner, Hier gleich ein potentieller Leak
Immer mit delete, das will doch wirklich keiner
Permanente Fehlerquelle, Zeitverschwendung, Ab jetzt als Raw-Pointer bezeichnet und nie wieder verwenden!
### 15
"Vererbt" von C
Pointer kurz erklären, kurz Owner (malloc/new) bzw. nur als Referenz erklären
Leaks, Owner nicht definiert, vor allem bei Librarys relevant
Pointer als Referenz
Pointer als Owner, Hier gleich ein potentieller Leak
Immer mit delete, das will doch wirklich keiner
Permanente Fehlerquelle, Zeitverschwendung, Ab jetzt als Raw-Pointer bezeichnet und nie wieder verwenden!
### 15
"Vererbt" von C
Pointer kurz erklären, kurz Owner (malloc/new) bzw. nur als Referenz erklären
Leaks, Owner nicht definiert, vor allem bei Librarys relevant
Pointer als Referenz
Pointer als Owner, Hier gleich ein potentieller Leak
Immer mit delete, das will doch wirklich keiner
Permanente Fehlerquelle, Zeitverschwendung, Ab jetzt als Raw-Pointer bezeichnet und nie wieder verwenden!
### 16
Erwähnung Operatorenüberladung und Lifetime
Quasi Drop-In-Replacement für Raw-Ptr, machen selber den Speicher am Ende der Lebenszeit Frei
Explizit verboten zu kopieren (=delete), Bsp. kopieren in Klasse, jetzt uneindeutiger Owner. Oftmals für Factory Methoden, kein Overhead zu Raw-Pointer
Zusätzlich Zählen von Instanzen (siehe Copy-Constructor)
Dafür kopieren... minimal langsamer (nicht bei Zugriff)
### 16
Erwähnung Operatorenüberladung und Lifetime
Quasi Drop-In-Replacement für Raw-Ptr, machen selber den Speicher am Ende der Lebenszeit Frei
Explizit verboten zu kopieren (=delete), Bsp. kopieren in Klasse, jetzt uneindeutiger Owner. Oftmals für Factory Methoden, kein Overhead zu Raw-Pointer
Zusätzlich Zählen von Instanzen (siehe Copy-Constructor)
Dafür kopieren... minimal langsamer (nicht bei Zugriff)
### 16
Erwähnung Operatorenüberladung und Lifetime
Quasi Drop-In-Replacement für Raw-Ptr, machen selber den Speicher am Ende der Lebenszeit Frei
Explizit verboten zu kopieren (=delete), Bsp. kopieren in Klasse, jetzt uneindeutiger Owner. Oftmals für Factory Methoden, kein Overhead zu Raw-Pointer
Zusätzlich Zählen von Instanzen (siehe Copy-Constructor)
Dafür kopieren... minimal langsamer (nicht bei Zugriff)
### 16
Erwähnung Operatorenüberladung und Lifetime
Quasi Drop-In-Replacement für Raw-Ptr, machen selber den Speicher am Ende der Lebenszeit Frei
Explizit verboten zu kopieren (=delete), Bsp. kopieren in Klasse, jetzt uneindeutiger Owner. Oftmals für Factory Methoden, kein Overhead zu Raw-Pointer
Zusätzlich Zählen von Instanzen (siehe Copy-Constructor)
Dafür kopieren... minimal langsamer (nicht bei Zugriff)
### 16
Erwähnung Operatorenüberladung und Lifetime
Quasi Drop-In-Replacement für Raw-Ptr, machen selber den Speicher am Ende der Lebenszeit Frei
Explizit verboten zu kopieren (=delete), Bsp. kopieren in Klasse, jetzt uneindeutiger Owner. Oftmals für Factory Methoden, kein Overhead zu Raw-Pointer
Zusätzlich Zählen von Instanzen (siehe Copy-Constructor)
Dafür kopieren... minimal langsamer (nicht bei Zugriff)
### 16
Erwähnung Operatorenüberladung und Lifetime
Quasi Drop-In-Replacement für Raw-Ptr, machen selber den Speicher am Ende der Lebenszeit Frei
Explizit verboten zu kopieren (=delete), Bsp. kopieren in Klasse, jetzt uneindeutiger Owner. Oftmals für Factory Methoden, kein Overhead zu Raw-Pointer
Zusätzlich Zählen von Instanzen (siehe Copy-Constructor)
Dafür kopieren... minimal langsamer (nicht bei Zugriff)
### 17
Werden vom Compiler zu Pointern gemacht, nie Owner. Hier betrachtet L-Value-Referenzen
Zeigen immer auf anderes Objekt, eine Art Alias
z.B. lokale Variablen
### 17
Werden vom Compiler zu Pointern gemacht, nie Owner. Hier betrachtet L-Value-Referenzen
Zeigen immer auf anderes Objekt, eine Art Alias
z.B. lokale Variablen
### 17
Werden vom Compiler zu Pointern gemacht, nie Owner. Hier betrachtet L-Value-Referenzen
Zeigen immer auf anderes Objekt, eine Art Alias
z.B. lokale Variablen
### 17
Werden vom Compiler zu Pointern gemacht, nie Owner. Hier betrachtet L-Value-Referenzen
Zeigen immer auf anderes Objekt, eine Art Alias
z.B. lokale Variablen
### 18
Ausser pre C++11 und mit C APIs
Limitierung: Ein Owner kein Overhead
Am Ähnlichsten zu Java, aber etwas Overhead (immer noch weniger als Java und definierte Lifetime)
Sprachfeature
### 18
Ausser pre C++11 und mit C APIs
Limitierung: Ein Owner kein Overhead
Am Ähnlichsten zu Java, aber etwas Overhead (immer noch weniger als Java und definierte Lifetime)
Sprachfeature
### 18
Ausser pre C++11 und mit C APIs
Limitierung: Ein Owner kein Overhead
Am Ähnlichsten zu Java, aber etwas Overhead (immer noch weniger als Java und definierte Lifetime)
Sprachfeature
### 18
Ausser pre C++11 und mit C APIs
Limitierung: Ein Owner kein Overhead
Am Ähnlichsten zu Java, aber etwas Overhead (immer noch weniger als Java und definierte Lifetime)
Sprachfeature
### 19
Wo Pointer/Ref einbauen? Frage welche Sorte Pointer. HelloWorld Lib Ergänzen mit Referenzen, jetzt in CLion
### 21
Beispiel: ausversehen einfügen in Map, allgemeine Fehlerquelle immer nur minimale Rechte
Ergänze Beispiel
Read-Only "nur anschauen"
Beispiel getter
Const am ende der Definition this ist in der Funktion konstant
Beispiel Mutex, Caching, nicht immer!
### 21
Beispiel: ausversehen einfügen in Map, allgemeine Fehlerquelle immer nur minimale Rechte
Ergänze Beispiel
Read-Only "nur anschauen"
Beispiel getter
Const am ende der Definition this ist in der Funktion konstant
Beispiel Mutex, Caching, nicht immer!
### 21
Beispiel: ausversehen einfügen in Map, allgemeine Fehlerquelle immer nur minimale Rechte
Ergänze Beispiel
Read-Only "nur anschauen"
Beispiel getter
Const am ende der Definition this ist in der Funktion konstant
Beispiel Mutex, Caching, nicht immer!
### 21
Beispiel: ausversehen einfügen in Map, allgemeine Fehlerquelle immer nur minimale Rechte
Ergänze Beispiel
Read-Only "nur anschauen"
Beispiel getter
Const am ende der Definition this ist in der Funktion konstant
Beispiel Mutex, Caching, nicht immer!
### 21
Beispiel: ausversehen einfügen in Map, allgemeine Fehlerquelle immer nur minimale Rechte
Ergänze Beispiel
Read-Only "nur anschauen"
Beispiel getter
Const am ende der Definition this ist in der Funktion konstant
Beispiel Mutex, Caching, nicht immer!
### 21
Beispiel: ausversehen einfügen in Map, allgemeine Fehlerquelle immer nur minimale Rechte
Ergänze Beispiel
Read-Only "nur anschauen"
Beispiel getter
Const am ende der Definition this ist in der Funktion konstant
Beispiel Mutex, Caching, nicht immer!
### 22
const einfügen hello world
### 23
Fehlerreduktion, Einfachheit
Bsp. Datei, Mutex, Vector. Vgl try catch finally java
Trailing return type, Const-Correctness, Objekte werden im Konstruktor initialisiert, alle Objekte werden im Konstruktor geschlossen
### 23
Fehlerreduktion, Einfachheit
Bsp. Datei, Mutex, Vector. Vgl try catch finally java
Trailing return type, Const-Correctness, Objekte werden im Konstruktor initialisiert, alle Objekte werden im Konstruktor geschlossen
### 23
Fehlerreduktion, Einfachheit
Bsp. Datei, Mutex, Vector. Vgl try catch finally java
Trailing return type, Const-Correctness, Objekte werden im Konstruktor initialisiert, alle Objekte werden im Konstruktor geschlossen
### 25
Hinweis unterschied Deklaration und Definition. Vererbung, Sichtbarkeit von Vererbung, public, private, Konstruktor, Trailing return type, const Const-Correctness
### 26
Initializierung in Braced-Initializer, Super-Konstruktor, this als Pointer
### 29
Castet Typen in kompatible Typen (hier von a nach T), kompatibilität wird zur Compile Time gecheckt
Castet zur Runtime, vor allem für Pointer und Polyphormismus, kann Null sein
Abstammung aus C, Erklärung mit Überladung
### 29
Castet Typen in kompatible Typen (hier von a nach T), kompatibilität wird zur Compile Time gecheckt
Castet zur Runtime, vor allem für Pointer und Polyphormismus, kann Null sein
Abstammung aus C, Erklärung mit Überladung
### 29
Castet Typen in kompatible Typen (hier von a nach T), kompatibilität wird zur Compile Time gecheckt
Castet zur Runtime, vor allem für Pointer und Polyphormismus, kann Null sein
Abstammung aus C, Erklärung mit Überladung
### 30
Typ wird hergeleitet, oftmals Praktisch (vgl. Iterator), spart redundanz. Potentielle Fehlerquelle, z.B. Proxy klasse (vgl. std::vector<bool>)
### 31
Lambda, capute group, argumente. Bind um Argumente fest zu binden (oder Reihenfolge ändern)
### 32
Definition von template mit Typen, Type Deduktion
### 34
Bisschen hässlich weil GCC 8 nicht in den Paketquellen
### 38
Standardlibrary, wird von der libc zur Verfügung gestellt, nicht immer existent z.B. MC, aber mit OS schon. Grob Aufteilung:
String, Math, Date \& Time, Smart Pointer
Strukturierte Sammlung von Objekten
Standardalgorithmen oftmals mit Containern
Standard-IO, Dateizugriff
Threads und Locking Mechanismen
### 38
Jeweils kleine Auswahl zeigen
### 38
Standardlibrary, wird von der libc zur Verfügung gestellt, nicht immer existent z.B. MC, aber mit OS schon. Grob Aufteilung:
String, Math, Date \& Time, Smart Pointer
Strukturierte Sammlung von Objekten
Standardalgorithmen oftmals mit Containern
Standard-IO, Dateizugriff
Threads und Locking Mechanismen
### 38
Jeweils kleine Auswahl zeigen
### 38
Standardlibrary, wird von der libc zur Verfügung gestellt, nicht immer existent z.B. MC, aber mit OS schon. Grob Aufteilung:
String, Math, Date \& Time, Smart Pointer
Strukturierte Sammlung von Objekten
Standardalgorithmen oftmals mit Containern
Standard-IO, Dateizugriff
Threads und Locking Mechanismen
### 38
Jeweils kleine Auswahl zeigen
### 38
Standardlibrary, wird von der libc zur Verfügung gestellt, nicht immer existent z.B. MC, aber mit OS schon. Grob Aufteilung:
String, Math, Date \& Time, Smart Pointer
Strukturierte Sammlung von Objekten
Standardalgorithmen oftmals mit Containern
Standard-IO, Dateizugriff
Threads und Locking Mechanismen
### 38
Jeweils kleine Auswahl zeigen
### 38
Standardlibrary, wird von der libc zur Verfügung gestellt, nicht immer existent z.B. MC, aber mit OS schon. Grob Aufteilung:
String, Math, Date \& Time, Smart Pointer
Strukturierte Sammlung von Objekten
Standardalgorithmen oftmals mit Containern
Standard-IO, Dateizugriff
Threads und Locking Mechanismen
### 38
Jeweils kleine Auswahl zeigen
### 38
Standardlibrary, wird von der libc zur Verfügung gestellt, nicht immer existent z.B. MC, aber mit OS schon. Grob Aufteilung:
String, Math, Date \& Time, Smart Pointer
Strukturierte Sammlung von Objekten
Standardalgorithmen oftmals mit Containern
Standard-IO, Dateizugriff
Threads und Locking Mechanismen
### 38
Jeweils kleine Auswahl zeigen
### 39
Wie in Java
Siehe oben
Siehe oben
Nur der Namespace, diverseste Funktionen
Auch exotisches wie Riemann-Zeta Funktion
Komplexe Zahlen und Hilfsfunktionen
Diverse Verteilungen und RNGs
Behandlung von Callable (Funktionen) wie Variablen (vgl. Funktionspointer)
### 39
Wie in Java
Siehe oben
Siehe oben
Nur der Namespace, diverseste Funktionen
Auch exotisches wie Riemann-Zeta Funktion
Komplexe Zahlen und Hilfsfunktionen
Diverse Verteilungen und RNGs
Behandlung von Callable (Funktionen) wie Variablen (vgl. Funktionspointer)
### 39
Wie in Java
Siehe oben
Siehe oben
Nur der Namespace, diverseste Funktionen
Auch exotisches wie Riemann-Zeta Funktion
Komplexe Zahlen und Hilfsfunktionen
Diverse Verteilungen und RNGs
Behandlung von Callable (Funktionen) wie Variablen (vgl. Funktionspointer)
### 39
Wie in Java
Siehe oben
Siehe oben
Nur der Namespace, diverseste Funktionen
Auch exotisches wie Riemann-Zeta Funktion
Komplexe Zahlen und Hilfsfunktionen
Diverse Verteilungen und RNGs
Behandlung von Callable (Funktionen) wie Variablen (vgl. Funktionspointer)
### 39
Wie in Java
Siehe oben
Siehe oben
Nur der Namespace, diverseste Funktionen
Auch exotisches wie Riemann-Zeta Funktion
Komplexe Zahlen und Hilfsfunktionen
Diverse Verteilungen und RNGs
Behandlung von Callable (Funktionen) wie Variablen (vgl. Funktionspointer)
### 39
Wie in Java
Siehe oben
Siehe oben
Nur der Namespace, diverseste Funktionen
Auch exotisches wie Riemann-Zeta Funktion
Komplexe Zahlen und Hilfsfunktionen
Diverse Verteilungen und RNGs
Behandlung von Callable (Funktionen) wie Variablen (vgl. Funktionspointer)
### 39
Wie in Java
Siehe oben
Siehe oben
Nur der Namespace, diverseste Funktionen
Auch exotisches wie Riemann-Zeta Funktion
Komplexe Zahlen und Hilfsfunktionen
Diverse Verteilungen und RNGs
Behandlung von Callable (Funktionen) wie Variablen (vgl. Funktionspointer)
### 39
Wie in Java
Siehe oben
Siehe oben
Nur der Namespace, diverseste Funktionen
Auch exotisches wie Riemann-Zeta Funktion
Komplexe Zahlen und Hilfsfunktionen
Diverse Verteilungen und RNGs
Behandlung von Callable (Funktionen) wie Variablen (vgl. Funktionspointer)
### 40
Größe muss zu Compile-Time feststehen, wie Array in C nur Sicher, Zugriff O(1), Einfügen unmöglich
Dynamisch angelegtes Array, Elemente können hinzugefügt werden aber nicht effizient, Zugriff O(1), Einfügen worst case O(n)
Verlinkte Array-Liste, Ausprache!, Zugriff O(1) (aber langsamer als vector), Einfügen an einem Ende O(1), Einfügen in der Mitte O(n)
Einfach bzw. doppelt verkettete Liste, Zugriff O(1), Einfügen O(1)
Menge und Abbildung von Key auf Value, finden von Elementen in O(log(n(), einfügen in O(log(n))
Genau genommen kein Container, Sammlung von mehreren bzw. 2 Objekten von unterschiedlichem Typ. Typen und Anzahl müssen zu Compile-Time bekannt sein
Variable vom Typ T die nicht existieren muss, zum Beispiel als Return-Wert mit Fehler
### 40
Größe muss zu Compile-Time feststehen, wie Array in C nur Sicher, Zugriff O(1), Einfügen unmöglich
Dynamisch angelegtes Array, Elemente können hinzugefügt werden aber nicht effizient, Zugriff O(1), Einfügen worst case O(n)
Verlinkte Array-Liste, Ausprache!, Zugriff O(1) (aber langsamer als vector), Einfügen an einem Ende O(1), Einfügen in der Mitte O(n)
Einfach bzw. doppelt verkettete Liste, Zugriff O(1), Einfügen O(1)
Menge und Abbildung von Key auf Value, finden von Elementen in O(log(n(), einfügen in O(log(n))
Genau genommen kein Container, Sammlung von mehreren bzw. 2 Objekten von unterschiedlichem Typ. Typen und Anzahl müssen zu Compile-Time bekannt sein
Variable vom Typ T die nicht existieren muss, zum Beispiel als Return-Wert mit Fehler
### 40
Größe muss zu Compile-Time feststehen, wie Array in C nur Sicher, Zugriff O(1), Einfügen unmöglich
Dynamisch angelegtes Array, Elemente können hinzugefügt werden aber nicht effizient, Zugriff O(1), Einfügen worst case O(n)
Verlinkte Array-Liste, Ausprache!, Zugriff O(1) (aber langsamer als vector), Einfügen an einem Ende O(1), Einfügen in der Mitte O(n)
Einfach bzw. doppelt verkettete Liste, Zugriff O(1), Einfügen O(1)
Menge und Abbildung von Key auf Value, finden von Elementen in O(log(n(), einfügen in O(log(n))
Genau genommen kein Container, Sammlung von mehreren bzw. 2 Objekten von unterschiedlichem Typ. Typen und Anzahl müssen zu Compile-Time bekannt sein
Variable vom Typ T die nicht existieren muss, zum Beispiel als Return-Wert mit Fehler
### 40
Größe muss zu Compile-Time feststehen, wie Array in C nur Sicher, Zugriff O(1), Einfügen unmöglich
Dynamisch angelegtes Array, Elemente können hinzugefügt werden aber nicht effizient, Zugriff O(1), Einfügen worst case O(n)
Verlinkte Array-Liste, Ausprache!, Zugriff O(1) (aber langsamer als vector), Einfügen an einem Ende O(1), Einfügen in der Mitte O(n)
Einfach bzw. doppelt verkettete Liste, Zugriff O(1), Einfügen O(1)
Menge und Abbildung von Key auf Value, finden von Elementen in O(log(n(), einfügen in O(log(n))
Genau genommen kein Container, Sammlung von mehreren bzw. 2 Objekten von unterschiedlichem Typ. Typen und Anzahl müssen zu Compile-Time bekannt sein
Variable vom Typ T die nicht existieren muss, zum Beispiel als Return-Wert mit Fehler
### 40
Größe muss zu Compile-Time feststehen, wie Array in C nur Sicher, Zugriff O(1), Einfügen unmöglich
Dynamisch angelegtes Array, Elemente können hinzugefügt werden aber nicht effizient, Zugriff O(1), Einfügen worst case O(n)
Verlinkte Array-Liste, Ausprache!, Zugriff O(1) (aber langsamer als vector), Einfügen an einem Ende O(1), Einfügen in der Mitte O(n)
Einfach bzw. doppelt verkettete Liste, Zugriff O(1), Einfügen O(1)
Menge und Abbildung von Key auf Value, finden von Elementen in O(log(n(), einfügen in O(log(n))
Genau genommen kein Container, Sammlung von mehreren bzw. 2 Objekten von unterschiedlichem Typ. Typen und Anzahl müssen zu Compile-Time bekannt sein
Variable vom Typ T die nicht existieren muss, zum Beispiel als Return-Wert mit Fehler
### 40
Größe muss zu Compile-Time feststehen, wie Array in C nur Sicher, Zugriff O(1), Einfügen unmöglich
Dynamisch angelegtes Array, Elemente können hinzugefügt werden aber nicht effizient, Zugriff O(1), Einfügen worst case O(n)
Verlinkte Array-Liste, Ausprache!, Zugriff O(1) (aber langsamer als vector), Einfügen an einem Ende O(1), Einfügen in der Mitte O(n)
Einfach bzw. doppelt verkettete Liste, Zugriff O(1), Einfügen O(1)
Menge und Abbildung von Key auf Value, finden von Elementen in O(log(n(), einfügen in O(log(n))
Genau genommen kein Container, Sammlung von mehreren bzw. 2 Objekten von unterschiedlichem Typ. Typen und Anzahl müssen zu Compile-Time bekannt sein
Variable vom Typ T die nicht existieren muss, zum Beispiel als Return-Wert mit Fehler
### 40
Größe muss zu Compile-Time feststehen, wie Array in C nur Sicher, Zugriff O(1), Einfügen unmöglich
Dynamisch angelegtes Array, Elemente können hinzugefügt werden aber nicht effizient, Zugriff O(1), Einfügen worst case O(n)
Verlinkte Array-Liste, Ausprache!, Zugriff O(1) (aber langsamer als vector), Einfügen an einem Ende O(1), Einfügen in der Mitte O(n)
Einfach bzw. doppelt verkettete Liste, Zugriff O(1), Einfügen O(1)
Menge und Abbildung von Key auf Value, finden von Elementen in O(log(n(), einfügen in O(log(n))
Genau genommen kein Container, Sammlung von mehreren bzw. 2 Objekten von unterschiedlichem Typ. Typen und Anzahl müssen zu Compile-Time bekannt sein
Variable vom Typ T die nicht existieren muss, zum Beispiel als Return-Wert mit Fehler
### 41
Type deduction wäre möglich (auto). Wie Pointer nur abstrakt, z.B. auch bei Liste, zentrales Element für Container und Algorithmen, abstraktion von Container, wieso nicht at O(n) in Liste
### 42
Deutlich kürzer, sicher beachte const Referenz, nur wenn Funktionen const
### 43
Wendet eine Funktion auf jedes Element eines Containers an
Sortiert ein Container, es kann ein eigener Komperator angegeben werden
Findet größtes/kleinstes Element/Index
### 43
Wendet eine Funktion auf jedes Element eines Containers an
Sortiert ein Container, es kann ein eigener Komperator angegeben werden
Findet größtes/kleinstes Element/Index
### 43
Wendet eine Funktion auf jedes Element eines Containers an
Sortiert ein Container, es kann ein eigener Komperator angegeben werden
Findet größtes/kleinstes Element/Index
### 44
Alles auf Basis von "Streams"
Abstrakte input und output Streams
Stellen Streams zur Verfügung für Standardein-/Ausgabe
Dateistream (RAII!)
### 44
Alles auf Basis von "Streams"
Abstrakte input und output Streams
Stellen Streams zur Verfügung für Standardein-/Ausgabe
Dateistream (RAII!)
### 44
Alles auf Basis von "Streams"
Abstrakte input und output Streams
Stellen Streams zur Verfügung für Standardein-/Ausgabe
Dateistream (RAII!)
### 45
Startet neuen Thread aus callable
Abstraktion, asynchroner Funktionsaufruf. Ergebnis in std::future
Gegenseitiger Ausschluss. lock_guard sperrt und entsperrt automatisch (RAII!)
Effiziente und kompakte Lösung für einzelne Variablen, auf denen Operationen Atomar sein sollen
### 45
Startet neuen Thread aus callable
Abstraktion, asynchroner Funktionsaufruf. Ergebnis in std::future
Gegenseitiger Ausschluss. lock_guard sperrt und entsperrt automatisch (RAII!)
Effiziente und kompakte Lösung für einzelne Variablen, auf denen Operationen Atomar sein sollen
### 45
Startet neuen Thread aus callable
Abstraktion, asynchroner Funktionsaufruf. Ergebnis in std::future
Gegenseitiger Ausschluss. lock_guard sperrt und entsperrt automatisch (RAII!)
Effiziente und kompakte Lösung für einzelne Variablen, auf denen Operationen Atomar sein sollen
### 45
Startet neuen Thread aus callable
Abstraktion, asynchroner Funktionsaufruf. Ergebnis in std::future
Gegenseitiger Ausschluss. lock_guard sperrt und entsperrt automatisch (RAII!)
Effiziente und kompakte Lösung für einzelne Variablen, auf denen Operationen Atomar sein sollen
### 47
Begründung: Baum nicht als STL-Datenstrukur, trotzdem STL Container notwendig, Templates, Pointer, in unter 150 Zeilen lösbar
### 47
Begründung: Baum nicht als STL-Datenstrukur, trotzdem STL Container notwendig, Templates, Pointer, in unter 150 Zeilen lösbar
### 48
Streams nutzen
Blockgröße 8-bit
Erstmal separate Template-Klasse für Baum, dann nutzen für Huffman
Nach passender Datenstruktur für Menge und Symbol mit Wahrscheinlichkeit fragen
Effizienz, jedes mal suchen, ein mal sortieren?
Recherche wie in STL möglich
Durch Baum laufen, nach Format a -> 001
Beispiel an Tafel!
### 48
Streams nutzen
Blockgröße 8-bit
Erstmal separate Template-Klasse für Baum, dann nutzen für Huffman
Nach passender Datenstruktur für Menge und Symbol mit Wahrscheinlichkeit fragen
Effizienz, jedes mal suchen, ein mal sortieren?
Recherche wie in STL möglich
Durch Baum laufen, nach Format a -> 001
Beispiel an Tafel!
### 48
Streams nutzen
Blockgröße 8-bit
Erstmal separate Template-Klasse für Baum, dann nutzen für Huffman
Nach passender Datenstruktur für Menge und Symbol mit Wahrscheinlichkeit fragen
Effizienz, jedes mal suchen, ein mal sortieren?
Recherche wie in STL möglich
Durch Baum laufen, nach Format a -> 001
Beispiel an Tafel!
### 48
Streams nutzen
Blockgröße 8-bit
Erstmal separate Template-Klasse für Baum, dann nutzen für Huffman
Nach passender Datenstruktur für Menge und Symbol mit Wahrscheinlichkeit fragen
Effizienz, jedes mal suchen, ein mal sortieren?
Recherche wie in STL möglich
Durch Baum laufen, nach Format a -> 001
Beispiel an Tafel!
### 48
Streams nutzen
Blockgröße 8-bit
Erstmal separate Template-Klasse für Baum, dann nutzen für Huffman
Nach passender Datenstruktur für Menge und Symbol mit Wahrscheinlichkeit fragen
Effizienz, jedes mal suchen, ein mal sortieren?
Recherche wie in STL möglich
Durch Baum laufen, nach Format a -> 001
Beispiel an Tafel!
### 48
Streams nutzen
Blockgröße 8-bit
Erstmal separate Template-Klasse für Baum, dann nutzen für Huffman
Nach passender Datenstruktur für Menge und Symbol mit Wahrscheinlichkeit fragen
Effizienz, jedes mal suchen, ein mal sortieren?
Recherche wie in STL möglich
Durch Baum laufen, nach Format a -> 001
Beispiel an Tafel!
### 48
Streams nutzen
Blockgröße 8-bit
Erstmal separate Template-Klasse für Baum, dann nutzen für Huffman
Nach passender Datenstruktur für Menge und Symbol mit Wahrscheinlichkeit fragen
Effizienz, jedes mal suchen, ein mal sortieren?
Recherche wie in STL möglich
Durch Baum laufen, nach Format a -> 001
Beispiel an Tafel!
### 48
Streams nutzen
Blockgröße 8-bit
Erstmal separate Template-Klasse für Baum, dann nutzen für Huffman
Nach passender Datenstruktur für Menge und Symbol mit Wahrscheinlichkeit fragen
Effizienz, jedes mal suchen, ein mal sortieren?
Recherche wie in STL möglich
Durch Baum laufen, nach Format a -> 001
Beispiel an Tafel!
### 48
Streams nutzen
Blockgröße 8-bit
Erstmal separate Template-Klasse für Baum, dann nutzen für Huffman
Nach passender Datenstruktur für Menge und Symbol mit Wahrscheinlichkeit fragen
Effizienz, jedes mal suchen, ein mal sortieren?
Recherche wie in STL möglich
Durch Baum laufen, nach Format a -> 001
Beispiel an Tafel!
### 49
Kleine Auswahl an Tools
Diverseste Bedinungen, z.B. auch Float, integration in CLion
Vergleiche JavaDoc, besonderheit: tparam. Beispiel Generiertes HTML
z.B. GDB, quasi beliebig, wichtigestes Tool
Erkennt Speicherlecks, undefiniertes Verhalten, aber Langsam
Wie Valgrind nur schnell und neuer
Statische Analyse, Fehler vor der Compilieren entdecken
z.B. GDB, quasi beliebig, wichtigestes Tool
Erkennt Speicherlecks, undefiniertes Verhalten, aber Langsam
Wie Valgrind nur schnell und neuer
Statische Analyse, Fehler vor der Compilieren entdecken
z.B. GDB, quasi beliebig, wichtigestes Tool
Erkennt Speicherlecks, undefiniertes Verhalten, aber Langsam
Wie Valgrind nur schnell und neuer
Statische Analyse, Fehler vor der Compilieren entdecken
z.B. GDB, quasi beliebig, wichtigestes Tool
Erkennt Speicherlecks, undefiniertes Verhalten, aber Langsam
Wie Valgrind nur schnell und neuer
Statische Analyse, Fehler vor der Compilieren entdecken
Segfault bauen, GDB nutzen Valgrind und Asan nutzen in CLion, z.B. Referenz auf Vector und dann push\_back
Neue Form von Referenz (ab C++11), primär benötigt wenn nicht triviale Speicherverwaltung
Speicher von einer Klasse an eine andere Übergeben, z.B. return, per default da, sonst wenn nicht triviale Speicherverwaltung
Wird per default angelegt, muss nur angelegt werden wenn nicht trivialer Speicher verwaltet wird
Nur spezielle Member Funktionen, einfach!
Wird selten benötigt, einfach einzulesen
Touring-vollständige Sprache zur CompileTime, type\_traits, bringt zwar Vorteile aber nicht notwendig
Neue Form von Referenz (ab C++11), primär benötigt wenn nicht triviale Speicherverwaltung
Speicher von einer Klasse an eine andere Übergeben, z.B. return, per default da, sonst wenn nicht triviale Speicherverwaltung
Wird per default angelegt, muss nur angelegt werden wenn nicht trivialer Speicher verwaltet wird
Nur spezielle Member Funktionen, einfach!
Wird selten benötigt, einfach einzulesen
Touring-vollständige Sprache zur CompileTime, type\_traits, bringt zwar Vorteile aber nicht notwendig
Neue Form von Referenz (ab C++11), primär benötigt wenn nicht triviale Speicherverwaltung
Speicher von einer Klasse an eine andere Übergeben, z.B. return, per default da, sonst wenn nicht triviale Speicherverwaltung
Wird per default angelegt, muss nur angelegt werden wenn nicht trivialer Speicher verwaltet wird
Nur spezielle Member Funktionen, einfach!
Wird selten benötigt, einfach einzulesen
Touring-vollständige Sprache zur CompileTime, type\_traits, bringt zwar Vorteile aber nicht notwendig
Neue Form von Referenz (ab C++11), primär benötigt wenn nicht triviale Speicherverwaltung
Speicher von einer Klasse an eine andere Übergeben, z.B. return, per default da, sonst wenn nicht triviale Speicherverwaltung
Wird per default angelegt, muss nur angelegt werden wenn nicht trivialer Speicher verwaltet wird
Nur spezielle Member Funktionen, einfach!
Wird selten benötigt, einfach einzulesen
Touring-vollständige Sprache zur CompileTime, type\_traits, bringt zwar Vorteile aber nicht notwendig
Neue Form von Referenz (ab C++11), primär benötigt wenn nicht triviale Speicherverwaltung
Speicher von einer Klasse an eine andere Übergeben, z.B. return, per default da, sonst wenn nicht triviale Speicherverwaltung
Wird per default angelegt, muss nur angelegt werden wenn nicht trivialer Speicher verwaltet wird
Nur spezielle Member Funktionen, einfach!
Wird selten benötigt, einfach einzulesen
Touring-vollständige Sprache zur CompileTime, type\_traits, bringt zwar Vorteile aber nicht notwendig
Neue Form von Referenz (ab C++11), primär benötigt wenn nicht triviale Speicherverwaltung
Speicher von einer Klasse an eine andere Übergeben, z.B. return, per default da, sonst wenn nicht triviale Speicherverwaltung
Wird per default angelegt, muss nur angelegt werden wenn nicht trivialer Speicher verwaltet wird
Nur spezielle Member Funktionen, einfach!
Wird selten benötigt, einfach einzulesen
Touring-vollständige Sprache zur CompileTime, type\_traits, bringt zwar Vorteile aber nicht notwendig
Dokumentation der Sprache und STL, deutsche Version ist Shit
Gut für Designentscheidungen
Was erzeugt der Compiler für Code auf unterschiedlichen Plattformen, eher als Spielzeug
Dieser Vortrag
Gutes Buch, deutliche Vertiefung
Dokumentation der Sprache und STL, deutsche Version ist Shit
Gut für Designentscheidungen
Was erzeugt der Compiler für Code auf unterschiedlichen Plattformen, eher als Spielzeug
Dieser Vortrag
Gutes Buch, deutliche Vertiefung
Dokumentation der Sprache und STL, deutsche Version ist Shit
Gut für Designentscheidungen
Was erzeugt der Compiler für Code auf unterschiedlichen Plattformen, eher als Spielzeug
Dieser Vortrag
Gutes Buch, deutliche Vertiefung
Dokumentation der Sprache und STL, deutsche Version ist Shit
Gut für Designentscheidungen
Was erzeugt der Compiler für Code auf unterschiedlichen Plattformen, eher als Spielzeug
Dieser Vortrag
Gutes Buch, deutliche Vertiefung
Dokumentation der Sprache und STL, deutsche Version ist Shit
Gut für Designentscheidungen
Was erzeugt der Compiler für Code auf unterschiedlichen Plattformen, eher als Spielzeug
Dieser Vortrag
Gutes Buch, deutliche Vertiefung
